using Microsoft.Data.SqlClient;
using System.Text.RegularExpressions;

namespace HockeyStatsAI.Infrastructure.Database;

/// <summary>
/// Executes SQL SELECT queries and formats the results for display.
/// Applies safety limits (TOP clauses) and supports multiple output formats.
/// </summary>
/// <remarks>
/// This class is registered as a singleton in <see cref="Configuration.ServiceCollectionExtensions.AddHockeyStatsServices"/>.
/// It is used in <see cref="Program"/> to execute SQL queries generated by <see cref="GeminiTranslator"/>.
/// The executor automatically adds TOP clauses to SELECT statements to limit result sets and prevent
/// accidentally returning millions of rows. It supports table, CSV, and JSON output formats.
/// </remarks>
public class SqlExecutor(string connectionString, int defaultRowLimit = 100, int commandTimeoutSeconds = 30)
{
    private readonly string _connectionString = connectionString;
    private readonly int _defaultRowLimit = defaultRowLimit;
    private readonly int _commandTimeoutSeconds = commandTimeoutSeconds;
    private static readonly Regex s_selectWithTopDetector = new(@"^\s*SELECT\s+(DISTINCT\s+)?TOP\s+", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.Compiled);
    private static readonly Regex s_leadingSelect = new(@"^\s*SELECT\b", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.Compiled);

    /// <summary>
    /// Output formats for query results.
    /// </summary>
    public enum OutputFormat
    {
        /// <summary>
        /// Human-readable table format with column names and values.
        /// </summary>
        Table,

        /// <summary>
        /// CSV format with headers and comma-separated values.
        /// </summary>
        Csv,

        /// <summary>
        /// JSON array of objects, one per row.
        /// </summary>
        Json
    }

    /// <summary>
    /// Executes a SQL query and outputs the results in the specified format.
    /// </summary>
    /// <param name="query">The SQL SELECT query to execute.</param>
    /// <param name="format">The output format (Table, CSV, or JSON).</param>
    /// <param name="rowLimitOverride">Optional override for the default row limit. If null, uses the default limit.</param>
    /// <remarks>
    /// This method:
    /// 1. Automatically adds TOP clause if not present (respects rowLimitOverride or defaultRowLimit)
    /// 2. Executes the query with the configured timeout
    /// 3. Formats and outputs results to Console based on the specified format
    /// Used in <see cref="Program"/> to execute and display query results after validation by <see cref="SqlSafetyValidator"/>.
    /// </remarks>
    public void ExecuteQuery(string query, OutputFormat format = OutputFormat.Table, int? rowLimitOverride = null)
    {
        string effectiveQuery = ApplyDefaultTopLimit(query, rowLimitOverride ?? _defaultRowLimit);
        using var connection = new SqlConnection(_connectionString);
        connection.Open();

        using var command = new SqlCommand(effectiveQuery, connection);
        command.CommandTimeout = _commandTimeoutSeconds;

        using var reader = command.ExecuteReader();
        switch (format)
        {
            case OutputFormat.Csv:
                WriteCsv(reader);
                break;
            case OutputFormat.Json:
                WriteJson(reader);
                break;
            default:
                WriteTable(reader);
                break;
        }
    }

    /// <summary>
    /// Applies a default TOP limit to a SELECT query if it doesn't already have one.
    /// </summary>
    /// <param name="sql">The SQL query to modify.</param>
    /// <param name="limit">The limit to apply (number of rows).</param>
    /// <returns>
    /// The SQL query with TOP clause added, or the original query if it's not a SELECT or already has TOP.
    /// </returns>
    /// <remarks>
    /// Inserts "TOP {limit}" after SELECT or SELECT DISTINCT. This prevents accidentally
    /// returning millions of rows and improves performance. The limit is configurable
    /// via configuration settings (SqlSafety:MaxTop).
    /// </remarks>
    private static string ApplyDefaultTopLimit(string sql, int limit)
    {
        if (!s_leadingSelect.IsMatch(sql))
        {
            return sql;
        }

        if (s_selectWithTopDetector.IsMatch(sql))
        {
            return sql;
        }

        // Insert TOP n after SELECT or SELECT DISTINCT
        return Regex.Replace(
            sql,
            pattern: @"^\s*SELECT\s+(DISTINCT\s+)?",
            evaluator: m => m.Value + $"TOP {limit} ",
            options: RegexOptions.IgnoreCase | RegexOptions.CultureInvariant
        );
    }

    /// <summary>
    /// Writes query results in table format (column: value pairs).
    /// </summary>
    /// <param name="reader">The data reader with query results.</param>
    private static void WriteTable(SqlDataReader reader)
    {
        while (reader.Read())
        {
            for (int i = 0; i < reader.FieldCount; i++)
            {
                Console.Write($"{reader.GetName(i)}: {reader.GetValue(i)} ");
            }
            Console.WriteLine();
        }
    }

    /// <summary>
    /// Writes query results in CSV format with headers.
    /// </summary>
    /// <param name="reader">The data reader with query results.</param>
    /// <remarks>
    /// Writes column headers first, then data rows. Properly escapes CSV values
    /// that contain commas, quotes, or newlines.
    /// </remarks>
    private static void WriteCsv(SqlDataReader reader)
    {
        // headers
        for (int i = 0; i < reader.FieldCount; i++)
        {
            if (i > 0) Console.Write(',');
            Console.Write(EscapeCsv(reader.GetName(i)));
        }
        Console.WriteLine();

        while (reader.Read())
        {
            for (int i = 0; i < reader.FieldCount; i++)
            {
                if (i > 0) Console.Write(',');
                Console.Write(EscapeCsv(reader.GetValue(i)?.ToString() ?? string.Empty));
            }
            Console.WriteLine();
        }
    }

    /// <summary>
    /// Escapes a CSV value by wrapping it in quotes and doubling internal quotes.
    /// </summary>
    /// <param name="value">The value to escape.</param>
    /// <returns>The escaped CSV value.</returns>
    /// <remarks>
    /// Escapes values containing commas, quotes, or newlines according to CSV standards.
    /// </remarks>
    private static string EscapeCsv(string value)
    {
        if (value.Contains('"') || value.Contains(',') || value.Contains('\n') || value.Contains('\r'))
        {
            return '"' + value.Replace("\"", "\"\"") + '"';
        }
        return value;
    }

    /// <summary>
    /// Writes query results in JSON format as an array of objects.
    /// </summary>
    /// <param name="reader">The data reader with query results.</param>
    /// <remarks>
    /// Each row is serialized as a JSON object with column names as keys.
    /// Null values are properly represented as null in JSON.
    /// </remarks>
    private static void WriteJson(SqlDataReader reader)
    {
        var rows = new List<Dictionary<string, object?>>();
        while (reader.Read())
        {
            var obj = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < reader.FieldCount; i++)
            {
                obj[reader.GetName(i)] = reader.IsDBNull(i) ? null : reader.GetValue(i);
            }
            rows.Add(obj);
        }
        var json = System.Text.Json.JsonSerializer.Serialize(rows, new System.Text.Json.JsonSerializerOptions { WriteIndented = false });
        Console.WriteLine(json);
    }
}

